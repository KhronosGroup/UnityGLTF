using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Linq;
using System.Globalization;
using System;

namespace InteractivityASTGenerator.Generators
{
    /// <summary>
    /// Generates GetAST method for a class
    /// </summary>
    public static class GetASTMethodGenerator
    {
        /// <summary>
        /// Generate the GetAST method for a class
        /// </summary>
        public static string GenerateGetASTMethod(ClassDeclarationSyntax classDeclaration, INamedTypeSymbol classSymbol, SemanticModel semanticModel)
        {
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            bool isGlobalNamespace = string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>";
            string astNamespace = "UnityGLTF.Interactivity.AST";
            
            var source = new StringBuilder();
            
            // Add necessary usings
            source.AppendLine("// <auto-generated/>");
            source.AppendLine("using System;");
            source.AppendLine("using System.Collections.Generic;");
            source.AppendLine("using System.Text;");
            source.AppendLine("using System.Reflection;");
            source.AppendLine($"using {astNamespace};");  // Reference to our AST namespace
            source.AppendLine("using UnityGLTF.Interactivity.Export;"); // Add reference to Export namespace for IInteractivityExport
            source.AppendLine("using UnityEngine;"); // Add reference to Unity Engine for GameObject
            source.AppendLine();
            
            // Begin namespace for actual class (only if not global)
            if (!isGlobalNamespace)
            {
                source.AppendLine($"namespace {namespaceName}");
                source.AppendLine("{");
            }
            
            string indent = isGlobalNamespace ? "" : "    ";
            
            // Create partial class with appropriate indentation and implement IInteractivityExport
            source.AppendLine($"{indent}public partial class {classSymbol.Name} : IInteractivityExport");
            source.AppendLine($"{indent}{{");

            // Add GetAST method that returns the ClassReflectionInfo structure
            source.AppendLine($"{indent}    /// <summary>");
            source.AppendLine($"{indent}    /// Returns the Class Reflection Information representing the structure of this class.");
            source.AppendLine($"{indent}    /// </summary>");
            source.AppendLine($"{indent}    /// <returns>A ClassReflectionInfo object representing the structure of this class.</returns>");
            source.AppendLine($"{indent}    public static {astNamespace}.ClassReflectionInfo GetAST()");
            source.AppendLine($"{indent}    {{");
            
            string fullClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            // Create explicit object instantiations and add members using .Add() methods
            source.AppendLine($"{indent}        var ast = new {astNamespace}.ClassReflectionInfo();");
            source.AppendLine($"{indent}        ast.Type = typeof({fullClassName});");

            // Add modifiers
            source.AppendLine($"{indent}        ast.Modifiers = new List<string>();");
            foreach (var modifier in classDeclaration.Modifiers)
            {
                source.AppendLine($"{indent}        ast.Modifiers.Add(\"{modifier.Text}\");");
            }
            
            // Add base types
            source.AppendLine($"{indent}        ast.BaseTypes = new List<Type>();");
            if (classDeclaration.BaseList != null)
            {
                foreach (var baseType in classDeclaration.BaseList.Types)
                {
                    var typeInfo = semanticModel.GetTypeInfo(baseType.Type);
                    string typeNameFormatted = typeInfo.Type?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) 
                        ?? baseType.Type.ToString();
                    source.AppendLine($"{indent}        ast.BaseTypes.Add(typeof({typeNameFormatted}));");
                }
            }
            
            // Add fields
            source.AppendLine($"{indent}        ast.Fields = new List<FieldInfo>();");
            foreach (var field in classDeclaration.DescendantNodes().OfType<FieldDeclarationSyntax>())
            {
                foreach (var variable in field.Declaration.Variables)
                {
                    var fieldSymbol = semanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
                    source.AppendLine($"{indent}        ast.Fields.Add(typeof({fullClassName}).GetField(\"{variable.Identifier.Text}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static));");
                }
            }
            
            // Add properties
            source.AppendLine($"{indent}        ast.Properties = new List<PropertyInfo>();");
            foreach (var property in classDeclaration.DescendantNodes().OfType<PropertyDeclarationSyntax>())
            {
                var propertySymbol = semanticModel.GetDeclaredSymbol(property) as IPropertySymbol;
                source.AppendLine($"{indent}        ast.Properties.Add(typeof({fullClassName}).GetProperty(\"{property.Identifier.Text}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static));");
            }
            
            // Add methods
            source.AppendLine($"{indent}        ast.Methods = new List<MethodInfo>();");
            foreach (var method in classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>())
            {
                var methodSymbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                string methodName = method.Identifier.Text;
                
                // Build parameter types array for GetMethod
                var parameterTypes = new StringBuilder();
                
                if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
                {
                    parameterTypes.Append("new Type[] { ");
                    for (int i = 0; i < methodSymbol.Parameters.Length; i++)
                    {
                        var param = methodSymbol.Parameters[i];
                        string paramTypeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        
                        parameterTypes.Append($"typeof({paramTypeName})");
                        
                        if (i < methodSymbol.Parameters.Length - 1)
                            parameterTypes.Append(", ");
                    }
                    parameterTypes.Append(" }");
                }
                else
                {
                    parameterTypes.Append("new Type[0]");
                }
                
                source.AppendLine($"{indent}        ast.Methods.Add(typeof({fullClassName}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, {parameterTypes}, null));");
            }
            
            // Method bodies using dictionary
            source.AppendLine($"{indent}        ast.MethodBodies = new Dictionary<string, MethodBodyInfo>();");
            
            foreach (var method in classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>())
            {
                var methodSymbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                string methodName = method.Identifier.Text;
                
                source.AppendLine($"{indent}        {{");
                source.AppendLine($"{indent}            var methodBodyInfo = new MethodBodyInfo();");
                
                // Get method with proper parameter types
                if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
                {
                    var parameterTypes = new StringBuilder("new Type[] { ");
                    
                    for (int i = 0; i < methodSymbol.Parameters.Length; i++)
                    {
                        var param = methodSymbol.Parameters[i];
                        string paramTypeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        
                        parameterTypes.Append($"typeof({paramTypeName})");
                        
                        if (i < methodSymbol.Parameters.Length - 1)
                            parameterTypes.Append(", ");
                    }
                    
                    parameterTypes.Append(" }");
                    
                    source.AppendLine($"{indent}            methodBodyInfo.Method = typeof({fullClassName}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, {parameterTypes}, null);");
                }
                else
                {
                    source.AppendLine($"{indent}            methodBodyInfo.Method = typeof({fullClassName}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, new Type[0], null);");
                }
                
                // Method body statements
                source.AppendLine($"{indent}            methodBodyInfo.Statements = new List<StatementInfo>();");
                
                if (method.Body != null)
                {
                    // Process body statements with semantic model
                    GenerateStatementsWithSemanticModel(method.Body, source, indent + "            ", semanticModel);
                }
                else if (method.ExpressionBody != null)
                {
                    // Expression-bodied method with semantic model
                    GenerateExpressionBodyWithSemanticModel(method.ExpressionBody, source, indent + "            ", semanticModel);
                }
                
                // Local variables dictionary
                source.AppendLine($"{indent}            methodBodyInfo.LocalVariables = new Dictionary<string, Type>();");
                
                if (method.Body != null)
                {
                    foreach (var localDecl in method.Body.DescendantNodes().OfType<LocalDeclarationStatementSyntax>())
                    {
                        foreach (var variable in localDecl.Declaration.Variables)
                        {
                            var variableSymbol = semanticModel.GetDeclaredSymbol(variable);
                            var typeInfo = semanticModel.GetTypeInfo(localDecl.Declaration.Type);
                            string typeName = typeInfo.Type?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) 
                                ?? localDecl.Declaration.Type.ToString();
                            
                            source.AppendLine($"{indent}            methodBodyInfo.LocalVariables[\"{variable.Identifier.Text}\"] = typeof({typeName});");
                        }
                    }
                }
                
                source.AppendLine($"{indent}            ast.MethodBodies[\"{methodName}\"] = methodBodyInfo;");
                source.AppendLine($"{indent}        }}");
            }
            
            source.AppendLine();
            source.AppendLine($"{indent}        return ast;");
            source.AppendLine($"{indent}    }}");
            
            // Add the OnInteractivityExport method implementation
            source.AppendLine();
            source.AppendLine($"{indent}    /// <summary>");
            source.AppendLine($"{indent}    /// Implements the IInteractivityExport interface to allow exporting this class to GLTF interactivity format");
            source.AppendLine($"{indent}    /// </summary>");
            source.AppendLine($"{indent}    /// <param name=\"export\">The export context</param>");
            source.AppendLine($"{indent}    public void OnInteractivityExport(GltfInteractivityExportNodes export)");
            source.AppendLine($"{indent}    {{");
            source.AppendLine($"{indent}        var k = new ClassReflectionASTWalker(GetAST());");
            
            // Check if the class derives from MonoBehaviour to safely access gameObject
            bool isMonoBehaviour = false;
            var currentType = classSymbol;
            
            while (currentType != null)
            {
                if (currentType.Name == "MonoBehaviour" && currentType.ContainingNamespace.ToString() == "UnityEngine")
                {
                    isMonoBehaviour = true;
                    break;
                }
                
                currentType = currentType.BaseType;
            }
            
            if (isMonoBehaviour)
            {
                source.AppendLine($"{indent}        k.OnInteractivityExport(export, this.gameObject);");
            }
            else
            {
                source.AppendLine($"{indent}        k.OnInteractivityExport(export, null);");
            }
            
            source.AppendLine($"{indent}    }}");
            
            source.AppendLine($"{indent}}}");
            
            if (!isGlobalNamespace)
            {
                source.AppendLine("}");
            }
            
            return source.ToString();
        }

        /// <summary>
        /// Generate statements with semantic model for proper type resolution
        /// </summary>
        private static void GenerateStatementsWithSemanticModel(BlockSyntax block, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            foreach (var statement in block.Statements)
            {
                GenerateStatementWithSemanticModel(statement, source, indent, semanticModel);
            }
        }

        /// <summary>
        /// Generate a single statement with semantic model for proper type resolution
        /// </summary>
        private static void GenerateStatementWithSemanticModel(StatementSyntax statement, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            // Create a variable for the statement
            source.AppendLine($"{indent}var statement = new StatementInfo();");
            source.AppendLine($"{indent}statement.Kind = StatementInfo.StatementKind.{GetStatementKind(statement)};");
            
            // Handle block statements
            if (statement is BlockSyntax blockStmt)
            {
                source.AppendLine($"{indent}statement.Children = new List<StatementInfo>();");
                
                foreach (var childStatement in blockStmt.Statements)
                {
                    GenerateStatementWithSemanticModel(childStatement, source, indent, semanticModel);
                }
            }
            // Handle for loops
            else if (statement is ForStatementSyntax forStmt)
            {
                source.AppendLine($"{indent}statement.Expressions = new List<ExpressionInfo>();");
                
                // Process initializer
                if (forStmt.Declaration != null)
                {
                    source.AppendLine($"{indent}var initExpr = new ExpressionInfo();");
                    source.AppendLine($"{indent}initExpr.Kind = ExpressionInfo.ExpressionKind.ForInitializer;");
                    
                    // Get type information for initializer
                    var typeInfo = semanticModel.GetTypeInfo(forStmt.Declaration.Type);
                    if (typeInfo.Type != null)
                    {
                        string typeName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}initExpr.ResultType = typeof({typeName});");
                    }
                    
                    // Process initializer variables and their values
                    if (forStmt.Declaration.Variables.Count > 0)
                    {
                        source.AppendLine($"{indent}initExpr.Children = new List<ExpressionInfo>();");
                        
                        foreach (var variable in forStmt.Declaration.Variables)
                        {
                            if (variable.Initializer != null)
                            {
                                source.AppendLine($"{indent}var assignExpr = new ExpressionInfo();");
                                source.AppendLine($"{indent}assignExpr.Kind = ExpressionInfo.ExpressionKind.Assignment;");
                                source.AppendLine($"{indent}assignExpr.Children = new List<ExpressionInfo>();");
                                
                                // Add identifier as left side
                                source.AppendLine($"{indent}var idExpr = new ExpressionInfo();");
                                source.AppendLine($"{indent}idExpr.Kind = ExpressionInfo.ExpressionKind.Identifier;");
                                if (typeInfo.Type != null)
                                {
                                    string typeName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                    source.AppendLine($"{indent}idExpr.ResultType = typeof({typeName});");
                                }
                                source.AppendLine($"{indent}idExpr.LiteralValue = \"{variable.Identifier.Text}\";");
                                source.AppendLine($"{indent}assignExpr.Children.Add(idExpr);");
                                
                                // Add initializer value as right side
                                GenerateExpressionWithSemanticModel(variable.Initializer.Value, source, indent, semanticModel, "initValueExpr");
                                source.AppendLine($"{indent}assignExpr.Children.Add(initValueExpr);");
                                
                                source.AppendLine($"{indent}initExpr.Children.Add(assignExpr);");
                            }
                        }
                    }
                    
                    source.AppendLine($"{indent}statement.Expressions.Add(initExpr);");
                }
                else
                {
                    // Handle initializers in the form of expressions (i.e., i = 0)
                    foreach (var initializer in forStmt.Initializers)
                    {
                        GenerateExpressionWithSemanticModel(initializer, source, indent, semanticModel, "forInitExpr");
                        source.AppendLine($"{indent}statement.Expressions.Add(forInitExpr);");
                    }
                }
                
                // Process condition
                if (forStmt.Condition != null)
                {
                    source.AppendLine($"{indent}var conditionExpr = new ExpressionInfo();");
                    source.AppendLine($"{indent}conditionExpr.Kind = ExpressionInfo.ExpressionKind.ForCondition;");
                    
                    var conditionTypeInfo = semanticModel.GetTypeInfo(forStmt.Condition);
                    if (conditionTypeInfo.Type != null)
                    {
                        string typeName = conditionTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}conditionExpr.ResultType = typeof({typeName});");
                    }
                    
                    source.AppendLine($"{indent}conditionExpr.Children = new List<ExpressionInfo>();");
                    
                    GenerateExpressionWithSemanticModel(forStmt.Condition, source, indent, semanticModel, "forCondValueExpr");
                    source.AppendLine($"{indent}conditionExpr.Children.Add(forCondValueExpr);");
                    
                    source.AppendLine($"{indent}statement.Expressions.Add(conditionExpr);");
                }
                
                // Process incrementors
                foreach (var incrementor in forStmt.Incrementors)
                {
                    source.AppendLine($"{indent}var incrementorExpr = new ExpressionInfo();");
                    source.AppendLine($"{indent}incrementorExpr.Kind = ExpressionInfo.ExpressionKind.ForIncrementor;");
                    
                    var incrementorTypeInfo = semanticModel.GetTypeInfo(incrementor);
                    if (incrementorTypeInfo.Type != null)
                    {
                        string typeName = incrementorTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}incrementorExpr.ResultType = typeof({typeName});");
                    }
                    
                    source.AppendLine($"{indent}incrementorExpr.Children = new List<ExpressionInfo>();");
                    
                    GenerateExpressionWithSemanticModel(incrementor, source, indent, semanticModel, "forIncrExpr");
                    source.AppendLine($"{indent}incrementorExpr.Children.Add(forIncrExpr);");
                    
                    source.AppendLine($"{indent}statement.Expressions.Add(incrementorExpr);");
                }
                
                // For loop body
                source.AppendLine($"{indent}statement.Children = new List<StatementInfo>();");
                
                if (forStmt.Statement is BlockSyntax forBlock)
                {
                    foreach (var childStatement in forBlock.Statements)
                    {
                        GenerateStatementWithSemanticModel(childStatement, source, indent, semanticModel);
                        source.AppendLine($"{indent}statement.Children.Add(statement);");
                    }
                }
                else
                {
                    GenerateStatementWithSemanticModel(forStmt.Statement, source, indent, semanticModel);
                    source.AppendLine($"{indent}statement.Children.Add(statement);");
                }
            }
            // Handle if statements
            else if (statement is IfStatementSyntax ifStmt)
            {
                source.AppendLine($"{indent}statement.Expressions = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(ifStmt.Condition, source, indent, semanticModel, "ifCondExpr");
                source.AppendLine($"{indent}statement.Expressions.Add(ifCondExpr);");
                
                source.AppendLine($"{indent}statement.Children = new List<StatementInfo>();");
                
                // Then clause
                source.AppendLine($"{indent}var thenStatement = new StatementInfo();");
                source.AppendLine($"{indent}thenStatement.Kind = StatementInfo.StatementKind.ThenClause;");
                source.AppendLine($"{indent}thenStatement.Children = new List<StatementInfo>();");
                
                if (ifStmt.Statement is BlockSyntax thenBlock)
                {
                    foreach (var childStatement in thenBlock.Statements)
                    {
                        GenerateStatementWithSemanticModel(childStatement, source, indent, semanticModel);
                        source.AppendLine($"{indent}thenStatement.Children.Add(statement);");
                    }
                }
                else
                {
                    GenerateStatementWithSemanticModel(ifStmt.Statement, source, indent, semanticModel);
                    source.AppendLine($"{indent}thenStatement.Children.Add(statement);");
                }
                
                source.AppendLine($"{indent}statement.Children.Add(thenStatement);");
                
                // Else clause if present
                if (ifStmt.Else != null)
                {
                    source.AppendLine($"{indent}var elseStatement = new StatementInfo();");
                    source.AppendLine($"{indent}elseStatement.Kind = StatementInfo.StatementKind.ElseClause;");
                    source.AppendLine($"{indent}elseStatement.Children = new List<StatementInfo>();");
                    
                    if (ifStmt.Else.Statement is BlockSyntax elseBlock)
                    {
                        foreach (var childStatement in elseBlock.Statements)
                        {
                            GenerateStatementWithSemanticModel(childStatement, source, indent, semanticModel);
                            source.AppendLine($"{indent}elseStatement.Children.Add(statement);");
                        }
                    }
                    else
                    {
                        GenerateStatementWithSemanticModel(ifStmt.Else.Statement, source, indent, semanticModel);
                        source.AppendLine($"{indent}elseStatement.Children.Add(statement);");
                    }
                    
                    source.AppendLine($"{indent}statement.Children.Add(elseStatement);");
                }
            }
            // Handle expressions
            else if (statement is ExpressionStatementSyntax exprStmt)
            {
                source.AppendLine($"{indent}statement.Expressions = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(exprStmt.Expression, source, indent, semanticModel, "stmtExpr");
                source.AppendLine($"{indent}statement.Expressions.Add(stmtExpr);");
            }
            // Handle return statements
            else if (statement is ReturnStatementSyntax returnStmt)
            {
                if (returnStmt.Expression != null)
                {
                    source.AppendLine($"{indent}statement.Expressions = new List<ExpressionInfo>();");
                    
                    GenerateExpressionWithSemanticModel(returnStmt.Expression, source, indent, semanticModel, "returnExpr");
                    source.AppendLine($"{indent}statement.Expressions.Add(returnExpr);");
                }
            }
            // Handle local declarations
            else if (statement is LocalDeclarationStatementSyntax localDecl)
            {
                source.AppendLine($"{indent}statement.Expressions = new List<ExpressionInfo>();");
                
                foreach (var variable in localDecl.Declaration.Variables)
                {
                    source.AppendLine($"{indent}var declExpr = new ExpressionInfo();");
                    source.AppendLine($"{indent}declExpr.Kind = ExpressionInfo.ExpressionKind.Identifier;");
                    
                    // Resolve the variable type using semantic model
                    var typeInfo = semanticModel.GetTypeInfo(localDecl.Declaration.Type);
                    if (typeInfo.Type != null)
                    {
                        string typeFullName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}declExpr.ResultType = typeof({typeFullName});");
                    }
                    
                    // If there's an initializer, include it with proper type resolution
                    if (variable.Initializer != null)
                    {
                        source.AppendLine($"{indent}declExpr.Children = new List<ExpressionInfo>();");
                        
                        GenerateExpressionWithSemanticModel(variable.Initializer.Value, source, indent, semanticModel, "initExpr");
                        source.AppendLine($"{indent}declExpr.Children.Add(initExpr);");
                    }
                    
                    source.AppendLine($"{indent}statement.Expressions.Add(declExpr);");
                }
            }
            
            source.AppendLine($"{indent}methodBodyInfo.Statements.Add(statement);");
        }

        /// <summary>
        /// Generate an expression body with semantic model for proper type resolution
        /// </summary>
        private static void GenerateExpressionBodyWithSemanticModel(ArrowExpressionClauseSyntax expressionBody, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            source.AppendLine($"{indent}var expressionBodyStmt = new StatementInfo();");
            source.AppendLine($"{indent}expressionBodyStmt.Kind = StatementInfo.StatementKind.ExpressionBody;");
            source.AppendLine($"{indent}expressionBodyStmt.Expressions = new List<ExpressionInfo>();");
            
            GenerateExpressionWithSemanticModel(expressionBody.Expression, source, indent, semanticModel, "exprBodyExpr");
            source.AppendLine($"{indent}expressionBodyStmt.Expressions.Add(exprBodyExpr);");
            
            source.AppendLine($"{indent}methodBodyInfo.Statements.Add(expressionBodyStmt);");
        }

        /// <summary>
        /// Generate an expression with semantic model for proper type resolution
        /// </summary>
        private static void GenerateExpressionWithSemanticModel(ExpressionSyntax expression, StringBuilder source, string indent, SemanticModel semanticModel, string varName)
        {
            if (expression == null)
            {
                source.AppendLine($"{indent}var {varName} = null;");
                return;
            }
            
            // Get type information using semantic model
            var typeInfo = semanticModel.GetTypeInfo(expression);
            string typeName = "object";
            if (typeInfo.Type != null)
            {
                typeName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
            
            // Object creation expressions (e.g. new Vector3(0,0,0))
            if (expression is ObjectCreationExpressionSyntax objectCreationExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.ObjectCreation,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Arguments list
                if (objectCreationExpr.ArgumentList != null && objectCreationExpr.ArgumentList.Arguments.Count > 0)
                {
                    source.AppendLine($"{indent}}};");
                    source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                    
                    int argIndex = 0;
                    foreach (var arg in objectCreationExpr.ArgumentList.Arguments)
                    {
                        string argVarName = $"{varName}_arg{argIndex}";
                        GenerateExpressionWithSemanticModel(arg.Expression, source, indent, semanticModel, argVarName);
                        source.AppendLine($"{indent}{varName}.Children.Add({argVarName});");
                        argIndex++;
                    }
                }
                else
                {
                    source.AppendLine($"{indent}}};");
                }
            }
            // Post-increment and post-decrement expressions (i++, i--)
            else if (expression is PostfixUnaryExpressionSyntax postfixExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.PostfixUnary,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{postfixExpr.OperatorToken.Text}\"");
                source.AppendLine($"{indent}}};");
                
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(postfixExpr.Operand, source, indent, semanticModel, $"{varName}_operand");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_operand);");
            }
            // Pre-increment and pre-decrement expressions (++i, --i)
            else if (expression is PrefixUnaryExpressionSyntax prefixExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.PrefixUnary,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{prefixExpr.OperatorToken.Text}\"");
                source.AppendLine($"{indent}}};");
                
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(prefixExpr.Operand, source, indent, semanticModel, $"{varName}_operand");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_operand);");
            }
            // Method invocations
            else if (expression is InvocationExpressionSyntax invocationExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.MethodInvocation,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Target method information
                var symbolInfo = semanticModel.GetSymbolInfo(invocationExpr);
                if (symbolInfo.Symbol is IMethodSymbol methodSymbol)
                {
                    string containingTypeName = methodSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    
                    // Build parameter types array for precise method resolution
                    string parameterTypesArray;
                    
                    if (methodSymbol.Parameters.Length > 0)
                    {
                        var typesBuilder = new StringBuilder("new Type[] { ");
                        
                        for (int i = 0; i < methodSymbol.Parameters.Length; i++)
                        {
                            var param = methodSymbol.Parameters[i];
                            string paramTypeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            
                            typesBuilder.Append($"typeof({paramTypeName})");
                            
                            if (i < methodSymbol.Parameters.Length - 1)
                                typesBuilder.Append(", ");
                        }
                        
                        typesBuilder.Append(" }");
                        parameterTypesArray = typesBuilder.ToString();
                    }
                    else
                    {
                        parameterTypesArray = "new Type[0]";
                    }
                    
                    source.AppendLine($"{indent}}};");
                    source.AppendLine($"{indent}{varName}.Method = typeof({containingTypeName}).GetMethod(\"{methodSymbol.Name}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, {parameterTypesArray}, null);");
                }
                else
                {
                    source.AppendLine($"{indent}}};");
                }
                
                // Target expression and arguments
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                // Target expression (e.g. obj in obj.Method())
                if (invocationExpr.Expression is MemberAccessExpressionSyntax memberAccess)
                {
                    GenerateExpressionWithSemanticModel(memberAccess.Expression, source, indent, semanticModel, $"{varName}_target");
                    source.AppendLine($"{indent}{varName}.Children.Add({varName}_target);");
                }
                
                // Arguments
                int argIdx = 0;
                foreach (var arg in invocationExpr.ArgumentList.Arguments)
                {
                    GenerateExpressionWithSemanticModel(arg.Expression, source, indent, semanticModel, $"{varName}_arg{argIdx}");
                    source.AppendLine($"{indent}{varName}.Children.Add({varName}_arg{argIdx});");
                    argIdx++;
                }
            }
            // Member access (e.g. obj.Property)
            else if (expression is MemberAccessExpressionSyntax memberAccessExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.MemberAccess,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Determine if it's a property or field
                var symbolInfo = semanticModel.GetSymbolInfo(memberAccessExpr.Name);
                if (symbolInfo.Symbol is IPropertySymbol propertySymbol)
                {
                    string containingTypeName = propertySymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    source.AppendLine($"{indent}}};");
                    source.AppendLine($"{indent}{varName}.Property = typeof({containingTypeName}).GetProperty(\"{propertySymbol.Name}\");");
                }
                else if (symbolInfo.Symbol is IFieldSymbol fieldSymbol)
                {
                    string containingTypeName = fieldSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    source.AppendLine($"{indent}}};");
                    source.AppendLine($"{indent}{varName}.Field = typeof({containingTypeName}).GetField(\"{fieldSymbol.Name}\");");
                }
                else
                {
                    source.AppendLine($"{indent}}};");
                }
                
                // The object being accessed
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(memberAccessExpr.Expression, source, indent, semanticModel, $"{varName}_obj");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_obj);");
            }
            // Literal values (e.g. "string", 42, true)
            else if (expression is LiteralExpressionSyntax literalExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Literal,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Get the literal value
                var constantValue = semanticModel.GetConstantValue(expression);
                if (constantValue.HasValue)
                {
                    object value = constantValue.Value;
                    if (value is string stringValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = \"{stringValue.Replace("\"", "\\\"")}\"");
                    }
                    else if (value == null)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = null");
                    }
                    else if (value is double doubleValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {doubleValue.ToString(CultureInfo.InvariantCulture)}");
                    }
                    else if (value is float floatValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {floatValue.ToString(CultureInfo.InvariantCulture)}f");
                    }
                    else if (value is decimal decimalValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {decimalValue.ToString(CultureInfo.InvariantCulture)}m");
                    }
                    else
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {Convert.ToString(value, CultureInfo.InvariantCulture)}");
                    }
                }
                
                source.AppendLine($"{indent}}};");
            }
            // Identifiers (variable names)
            else if (expression is IdentifierNameSyntax identifierExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Identifier,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    LiteralValue = \"{identifierExpr.Identifier.Text}\"");
                source.AppendLine($"{indent}}};");
            }
            // Binary expressions (e.g. a + b)
            else if (expression is BinaryExpressionSyntax binaryExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Binary,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{binaryExpr.OperatorToken.Text}\"");
                source.AppendLine($"{indent}}};");
                
                // Left and right expressions
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(binaryExpr.Left, source, indent, semanticModel, $"{varName}_left");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_left);");
                
                GenerateExpressionWithSemanticModel(binaryExpr.Right, source, indent, semanticModel, $"{varName}_right");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_right);");
            }
            // Assignment expressions (a = b)
            else if (expression is AssignmentExpressionSyntax assignmentExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Assignment,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{assignmentExpr.OperatorToken.Text}\"");
                source.AppendLine($"{indent}}};");
                
                // Left and right expressions
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(assignmentExpr.Left, source, indent, semanticModel, $"{varName}_left");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_left);");
                
                GenerateExpressionWithSemanticModel(assignmentExpr.Right, source, indent, semanticModel, $"{varName}_right");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_right);");
            }
            // Switch expressions
            else if (expression is SwitchExpressionSyntax switchExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.SwitchExpression,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                source.AppendLine($"{indent}}};");
                
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                // First child is always the governing expression
                GenerateExpressionWithSemanticModel(switchExpr.GoverningExpression, source, indent, semanticModel, $"{varName}_gov");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_gov);");
                
                // Then add each switch arm as children
                int armIdx = 0;
                foreach (var arm in switchExpr.Arms)
                {
                    source.AppendLine($"{indent}var {varName}_arm{armIdx} = new ExpressionInfo");
                    source.AppendLine($"{indent}{{");
                    source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.SwitchArm");
                    source.AppendLine($"{indent}}};");
                    
                    source.AppendLine($"{indent}{varName}_arm{armIdx}.Children = new List<ExpressionInfo>();");
                    
                    // Pattern is first child of arm
                    source.AppendLine($"{indent}var {varName}_pattern{armIdx} = new ExpressionInfo");
                    source.AppendLine($"{indent}{{");
                    source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.SwitchPattern");
                    
                    // Get type info for pattern if possible
                    var patternTypeInfo = semanticModel.GetTypeInfo(arm.Pattern);
                    if (patternTypeInfo.Type != null)
                    {
                        string patternTypeName = patternTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    ResultType = typeof({patternTypeName})");
                    }
                    
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    LiteralValue = \"{arm.Pattern.ToString().Replace("\"", "\\\"")}\"");
                    source.AppendLine($"{indent}}};");
                    
                    source.AppendLine($"{indent}{varName}_arm{armIdx}.Children.Add({varName}_pattern{armIdx});");
                    
                    // Expression is second child of arm
                    GenerateExpressionWithSemanticModel(arm.Expression, source, indent, semanticModel, $"{varName}_expr{armIdx}");
                    source.AppendLine($"{indent}{varName}_arm{armIdx}.Children.Add({varName}_expr{armIdx});");
                    
                    source.AppendLine($"{indent}{varName}.Children.Add({varName}_arm{armIdx});");
                    armIdx++;
                }
            }
            // Await expressions
            else if (expression is AwaitExpressionSyntax awaitExpr)
            {
                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.AwaitExpression,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                source.AppendLine($"{indent}}};");
                
                source.AppendLine($"{indent}{varName}.Children = new List<ExpressionInfo>();");
                
                GenerateExpressionWithSemanticModel(awaitExpr.Expression, source, indent, semanticModel, $"{varName}_awaited");
                source.AppendLine($"{indent}{varName}.Children.Add({varName}_awaited);");
            }
            // Default fallback for any other expression type
            else
            {
                // Log warning for unknown expression type
                System.Diagnostics.Debug.WriteLine($"WARNING: Unknown expression type: {expression.GetType().Name} in {expression}");

                source.AppendLine($"{indent}var {varName} = new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Unknown,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                source.AppendLine($"{indent}}};");
            }
        }

        /// <summary>
        /// Get the appropriate StatementInfo.StatementKind for a statement
        /// </summary>
        private static string GetStatementKind(StatementSyntax statement)
        {
            if (statement is BlockSyntax) return "Block";
            if (statement is IfStatementSyntax) return "If";
            if (statement is ForStatementSyntax) return "For";
            if (statement is ForEachStatementSyntax) return "ForEach";
            if (statement is WhileStatementSyntax) return "While";
            if (statement is DoStatementSyntax) return "Do";
            if (statement is SwitchStatementSyntax) return "Switch";
            if (statement is ReturnStatementSyntax) return "Return";
            if (statement is ExpressionStatementSyntax) return "Expression";
            if (statement is LocalDeclarationStatementSyntax) return "Declaration";
            if (statement is BreakStatementSyntax) return "Break";
            if (statement is ContinueStatementSyntax) return "Continue";
            if (statement is ThrowStatementSyntax) return "Throw";
            if (statement is TryStatementSyntax) return "Try";
            
            // Log warning for unknown statement type
            System.Diagnostics.Debug.WriteLine($"WARNING: Unknown statement type: {statement.GetType().Name} in {statement}");
            
            return "Unknown";
        }
    }
}