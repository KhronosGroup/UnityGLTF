using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Linq;
using System.Globalization;
using System;

namespace InteractivityASTGenerator.Generators
{
    /// <summary>
    /// Generates GetAST method for a class
    /// </summary>
    public static class GetASTMethodGenerator
    {
        /// <summary>
        /// Generate the GetAST method for a class
        /// </summary>
        public static string GenerateGetASTMethod(ClassDeclarationSyntax classDeclaration, INamedTypeSymbol classSymbol, SemanticModel semanticModel)
        {
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            bool isGlobalNamespace = string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>";
            string astNamespace = "UnityGLTF.Interactivity.AST";
            
            var source = new StringBuilder();
            
            // Add necessary usings
            source.AppendLine("// <auto-generated/>");
            source.AppendLine("using System;");
            source.AppendLine("using System.Collections.Generic;");
            source.AppendLine("using System.Text;");
            source.AppendLine("using System.Reflection;");
            source.AppendLine($"using {astNamespace};");  // Reference to our AST namespace
            source.AppendLine("using UnityGLTF.Interactivity.Export;"); // Add reference to Export namespace for IInteractivityExport
            source.AppendLine("using UnityEngine;"); // Add reference to Unity Engine for GameObject
            source.AppendLine();
            
            // Begin namespace for actual class (only if not global)
            if (!isGlobalNamespace)
            {
                source.AppendLine($"namespace {namespaceName}");
                source.AppendLine("{");
            }
            
            string indent = isGlobalNamespace ? "" : "    ";
            
            // Create partial class with appropriate indentation and implement IInteractivityExport
            source.AppendLine($"{indent}public partial class {classSymbol.Name} : IInteractivityExport");
            source.AppendLine($"{indent}{{");

            // Add GetAST method that returns the ClassReflectionInfo structure
            source.AppendLine($"{indent}    /// <summary>");
            source.AppendLine($"{indent}    /// Returns the Class Reflection Information representing the structure of this class.");
            source.AppendLine($"{indent}    /// </summary>");
            source.AppendLine($"{indent}    /// <returns>A ClassReflectionInfo object representing the structure of this class.</returns>");
            source.AppendLine($"{indent}    public static {astNamespace}.ClassReflectionInfo GetAST()");
            source.AppendLine($"{indent}    {{");
            
            string fullClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            // Create object initializer for the entire AST
            source.AppendLine($"{indent}        return new {astNamespace}.ClassReflectionInfo");
            source.AppendLine($"{indent}        {{");
            source.AppendLine($"{indent}            Type = typeof({fullClassName}),");
            
            // Add modifiers
            source.AppendLine($"{indent}            Modifiers = new List<string>");
            source.AppendLine($"{indent}            {{");
            foreach (var modifier in classDeclaration.Modifiers)
            {
                source.AppendLine($"{indent}                \"{modifier.Text}\",");
            }
            source.AppendLine($"{indent}            }},");
            
            // Add base types
            source.AppendLine($"{indent}            BaseTypes = new List<Type>");
            source.AppendLine($"{indent}            {{");
            if (classDeclaration.BaseList != null)
            {
                foreach (var baseType in classDeclaration.BaseList.Types)
                {
                    var typeInfo = semanticModel.GetTypeInfo(baseType.Type);
                    string typeNameFormatted = typeInfo.Type?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) 
                        ?? baseType.Type.ToString();
                    source.AppendLine($"{indent}                typeof({typeNameFormatted}),");
                }
            }
            source.AppendLine($"{indent}            }},");
            
            // Add fields
            source.AppendLine($"{indent}            Fields = new List<FieldInfo>");
            source.AppendLine($"{indent}            {{");
            foreach (var field in classDeclaration.DescendantNodes().OfType<FieldDeclarationSyntax>())
            {
                foreach (var variable in field.Declaration.Variables)
                {
                    var fieldSymbol = semanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
                    source.AppendLine($"{indent}                typeof({fullClassName}).GetField(\"{variable.Identifier.Text}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static),");
                }
            }
            source.AppendLine($"{indent}            }},");
            
            // Add properties
            source.AppendLine($"{indent}            Properties = new List<PropertyInfo>");
            source.AppendLine($"{indent}            {{");
            foreach (var property in classDeclaration.DescendantNodes().OfType<PropertyDeclarationSyntax>())
            {
                var propertySymbol = semanticModel.GetDeclaredSymbol(property) as IPropertySymbol;
                source.AppendLine($"{indent}                typeof({fullClassName}).GetProperty(\"{property.Identifier.Text}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static),");
            }
            source.AppendLine($"{indent}            }},");
            
            // Add methods
            source.AppendLine($"{indent}            Methods = new List<MethodInfo>");
            source.AppendLine($"{indent}            {{");
            foreach (var method in classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>())
            {
                var methodSymbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                string methodName = method.Identifier.Text;
                
                // Build parameter types array for GetMethod
                var parameterTypes = new StringBuilder();
                
                if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
                {
                    parameterTypes.Append("new Type[] { ");
                    for (int i = 0; i < methodSymbol.Parameters.Length; i++)
                    {
                        var param = methodSymbol.Parameters[i];
                        string paramTypeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        
                        parameterTypes.Append($"typeof({paramTypeName})");
                        
                        if (i < methodSymbol.Parameters.Length - 1)
                            parameterTypes.Append(", ");
                    }
                    parameterTypes.Append(" }");
                }
                else
                {
                    parameterTypes.Append("new Type[0]");
                }
                
                source.AppendLine($"{indent}                typeof({fullClassName}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, {parameterTypes}, null),");
            }
            source.AppendLine($"{indent}            }},");
            
            // Method bodies using dictionary
            source.AppendLine($"{indent}            MethodBodies = new Dictionary<string, MethodBodyInfo>");
            source.AppendLine($"{indent}            {{");
            
            foreach (var method in classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>())
            {
                var methodSymbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                string methodName = method.Identifier.Text;
                
                source.AppendLine($"{indent}                {{ \"{methodName}\", new MethodBodyInfo");
                source.AppendLine($"{indent}                {{");
                
                // Get method with proper parameter types
                if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
                {
                    var parameterTypes = new StringBuilder("new Type[] { ");
                    
                    for (int i = 0; i < methodSymbol.Parameters.Length; i++)
                    {
                        var param = methodSymbol.Parameters[i];
                        string paramTypeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        
                        parameterTypes.Append($"typeof({paramTypeName})");
                        
                        if (i < methodSymbol.Parameters.Length - 1)
                            parameterTypes.Append(", ");
                    }
                    
                    parameterTypes.Append(" }");
                    
                    source.AppendLine($"{indent}                    Method = typeof({fullClassName}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, {parameterTypes}, null),");
                }
                else
                {
                    source.AppendLine($"{indent}                    Method = typeof({fullClassName}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, new Type[0], null),");
                }
                
                // Method body statements
                source.AppendLine($"{indent}                    Statements = new List<StatementInfo>");
                source.AppendLine($"{indent}                    {{");
                
                if (method.Body != null)
                {
                    // Process body statements with semantic model
                    GenerateStatementsWithSemanticModel(method.Body, source, indent + "                        ", semanticModel);
                }
                else if (method.ExpressionBody != null)
                {
                    // Expression-bodied method with semantic model
                    GenerateExpressionBodyWithSemanticModel(method.ExpressionBody, source, indent + "                        ", semanticModel);
                }
                
                source.AppendLine($"{indent}                    }},");
                
                // Local variables dictionary
                source.AppendLine($"{indent}                    LocalVariables = new Dictionary<string, Type>");
                source.AppendLine($"{indent}                    {{");
                
                if (method.Body != null)
                {
                    foreach (var localDecl in method.Body.DescendantNodes().OfType<LocalDeclarationStatementSyntax>())
                    {
                        foreach (var variable in localDecl.Declaration.Variables)
                        {
                            var variableSymbol = semanticModel.GetDeclaredSymbol(variable);
                            var typeInfo = semanticModel.GetTypeInfo(localDecl.Declaration.Type);
                            string typeName = typeInfo.Type?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) 
                                ?? localDecl.Declaration.Type.ToString();
                            
                            source.AppendLine($"{indent}                        {{ \"{variable.Identifier.Text}\", typeof({typeName}) }},");
                        }
                    }
                }
                
                source.AppendLine($"{indent}                    }}");
                source.AppendLine($"{indent}                }}}},");
            }
            
            source.AppendLine($"{indent}            }}");
            source.AppendLine($"{indent}        }};");
            
            // Add the OnInteractivityExport method implementation
            source.AppendLine();
            source.AppendLine($"{indent}    }}");
            source.AppendLine();
            source.AppendLine($"{indent}    /// <summary>");
            source.AppendLine($"{indent}    /// Implements the IInteractivityExport interface to allow exporting this class to GLTF interactivity format");
            source.AppendLine($"{indent}    /// </summary>");
            source.AppendLine($"{indent}    /// <param name=\"export\">The export context</param>");
            source.AppendLine($"{indent}    public void OnInteractivityExport(GltfInteractivityExportNodes export)");
            source.AppendLine($"{indent}    {{");
            source.AppendLine($"{indent}        var k = new ClassReflectionASTWalker(GetAST());");
            
            // Check if the class derives from MonoBehaviour to safely access gameObject
            bool isMonoBehaviour = false;
            var currentType = classSymbol;
            
            while (currentType != null)
            {
                if (currentType.Name == "MonoBehaviour" && currentType.ContainingNamespace.ToString() == "UnityEngine")
                {
                    isMonoBehaviour = true;
                    break;
                }
                
                currentType = currentType.BaseType;
            }
            
            if (isMonoBehaviour)
            {
                source.AppendLine($"{indent}        k.OnInteractivityExport(export, this);");
            }
            else
            {
                source.AppendLine($"{indent}        k.OnInteractivityExport(export, null);");
            }
            
            source.AppendLine($"{indent}    }}");
            
            source.AppendLine($"{indent}}}");
            
            if (!isGlobalNamespace)
            {
                source.AppendLine("}");
            }
            
            return source.ToString();
        }

        /// <summary>
        /// Generate statements with semantic model for proper type resolution
        /// </summary>
        private static void GenerateStatementsWithSemanticModel(BlockSyntax block, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            foreach (var statement in block.Statements)
            {
                GenerateStatementInitializer(statement, source, indent, semanticModel);
                source.AppendLine($"{indent},");
            }
        }

        /// <summary>
        /// Generate a single statement with semantic model for proper type resolution
        /// </summary>
        private static void GenerateStatementInitializer(StatementSyntax statement, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            // Create a statement initializer
            source.AppendLine($"{indent}new StatementInfo");
            source.AppendLine($"{indent}{{");
            source.AppendLine($"{indent}    Kind = StatementInfo.StatementKind.{GetStatementKind(statement)},");
            
            // Handle block statements
            if (statement is BlockSyntax blockStmt)
            {
                source.AppendLine($"{indent}    Children = new List<StatementInfo>");
                source.AppendLine($"{indent}    {{");
                
                foreach (var childStatement in blockStmt.Statements)
                {
                    GenerateStatementInitializer(childStatement, source, indent + "        ", semanticModel);
                    source.Append(",");
                    source.AppendLine();
                }
                
                source.AppendLine($"{indent}    }}");
            }
            // Handle for loops
            else if (statement is ForStatementSyntax forStmt)
            {
                source.AppendLine($"{indent}    Expressions = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Process initializer
                if (forStmt.Declaration != null)
                {
                    source.AppendLine($"{indent}        new ExpressionInfo");
                    source.AppendLine($"{indent}        {{");
                    source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.ForInitializer,");
                    
                    // Get type information for initializer
                    var typeInfo = semanticModel.GetTypeInfo(forStmt.Declaration.Type);
                    if (typeInfo.Type != null)
                    {
                        string typeName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}            ResultType = typeof({typeName}),");
                    }
                    
                    // Process initializer variables and their values
                    if (forStmt.Declaration.Variables.Count > 0)
                    {
                        source.AppendLine($"{indent}            Children = new List<ExpressionInfo>");
                        source.AppendLine($"{indent}            {{");
                        
                        foreach (var variable in forStmt.Declaration.Variables)
                        {
                            if (variable.Initializer != null)
                            {
                                source.AppendLine($"{indent}                new ExpressionInfo");
                                source.AppendLine($"{indent}                {{");
                                source.AppendLine($"{indent}                    Kind = ExpressionInfo.ExpressionKind.Assignment,");
                                source.AppendLine($"{indent}                    Children = new List<ExpressionInfo>");
                                source.AppendLine($"{indent}                    {{");
                                
                                // Add identifier as left side
                                source.AppendLine($"{indent}                        new ExpressionInfo");
                                source.AppendLine($"{indent}                        {{");
                                source.AppendLine($"{indent}                            Kind = ExpressionInfo.ExpressionKind.Identifier,");
                                if (typeInfo.Type != null)
                                {
                                    string typeName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                    source.AppendLine($"{indent}                            ResultType = typeof({typeName}),");
                                }
                                source.AppendLine($"{indent}                            LiteralValue = \"{variable.Identifier.Text}\"");
                                source.AppendLine($"{indent}                        }},");
                                
                                // Add initializer value as right side
                                GenerateExpressionInitializer(variable.Initializer.Value, source, indent + "                        ", semanticModel);
                                source.Append(",");
                                source.AppendLine();
                                
                                source.AppendLine($"{indent}                    }}");
                                source.AppendLine($"{indent}                }},");
                            }
                        }
                        
                        source.AppendLine($"{indent}            }}");
                    }
                    
                    source.AppendLine($"{indent}        }},");
                }
                else
                {
                    // Handle initializers in the form of expressions (i.e., i = 0)
                    foreach (var initializer in forStmt.Initializers)
                    {
                        GenerateExpressionInitializer(initializer, source, indent + "        ", semanticModel);
                        source.Append(",");
                        source.AppendLine();
                    }
                }
                
                // Process condition
                if (forStmt.Condition != null)
                {
                    source.AppendLine($"{indent}        new ExpressionInfo");
                    source.AppendLine($"{indent}        {{");
                    source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.ForCondition,");
                    
                    var conditionTypeInfo = semanticModel.GetTypeInfo(forStmt.Condition);
                    if (conditionTypeInfo.Type != null)
                    {
                        string typeName = conditionTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}            ResultType = typeof({typeName}),");
                    }
                    
                    source.AppendLine($"{indent}            Children = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}            {{");
                    
                    GenerateExpressionInitializer(forStmt.Condition, source, indent + "                ", semanticModel);
                    
                    source.AppendLine();
                    source.AppendLine($"{indent}            }}");
                    source.AppendLine($"{indent}        }},");
                }
                
                // Process incrementors
                foreach (var incrementor in forStmt.Incrementors)
                {
                    source.AppendLine($"{indent}        new ExpressionInfo");
                    source.AppendLine($"{indent}        {{");
                    source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.ForIncrementor,");
                    
                    var incrementorTypeInfo = semanticModel.GetTypeInfo(incrementor);
                    if (incrementorTypeInfo.Type != null)
                    {
                        string typeName = incrementorTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}            ResultType = typeof({typeName}),");
                    }
                    
                    source.AppendLine($"{indent}            Children = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}            {{");
                    
                    GenerateExpressionInitializer(incrementor, source, indent + "                ", semanticModel);
                    
                    source.AppendLine();
                    source.AppendLine($"{indent}            }}");
                    source.AppendLine($"{indent}        }},");
                }
                
                source.AppendLine($"{indent}    }},");
                
                // For loop body
                source.AppendLine($"{indent}    Children = new List<StatementInfo>");
                source.AppendLine($"{indent}    {{");
                
                if (forStmt.Statement is BlockSyntax forBlock)
                {
                    foreach (var childStatement in forBlock.Statements)
                    {
                        GenerateStatementInitializer(childStatement, source, indent + "        ", semanticModel);
                        source.Append(",");
                        source.AppendLine();
                    }
                }
                else
                {
                    GenerateStatementInitializer(forStmt.Statement, source, indent + "        ", semanticModel);
                    source.Append(",");
                    source.AppendLine();
                }
                
                source.AppendLine($"{indent}    }}");
            }
            // Handle if statements
            else if (statement is IfStatementSyntax ifStmt)
            {
                source.AppendLine($"{indent}    Expressions = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(ifStmt.Condition, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }},");
                
                source.AppendLine($"{indent}    Children = new List<StatementInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Then clause
                source.AppendLine($"{indent}        new StatementInfo");
                source.AppendLine($"{indent}        {{");
                source.AppendLine($"{indent}            Kind = StatementInfo.StatementKind.ThenClause,");
                source.AppendLine($"{indent}            Children = new List<StatementInfo>");
                source.AppendLine($"{indent}            {{");
                
                if (ifStmt.Statement is BlockSyntax thenBlock)
                {
                    foreach (var childStatement in thenBlock.Statements)
                    {
                        GenerateStatementInitializer(childStatement, source, indent + "                ", semanticModel);
                        source.Append(",");
                        source.AppendLine();
                    }
                }
                else
                {
                    GenerateStatementInitializer(ifStmt.Statement, source, indent + "                ", semanticModel);
                    source.Append(",");
                    source.AppendLine();
                }
                
                source.AppendLine($"{indent}            }}");
                source.AppendLine($"{indent}        }},");
                
                // Else clause if present
                if (ifStmt.Else != null)
                {
                    source.AppendLine($"{indent}        new StatementInfo");
                    source.AppendLine($"{indent}        {{");
                    source.AppendLine($"{indent}            Kind = StatementInfo.StatementKind.ElseClause,");
                    source.AppendLine($"{indent}            Children = new List<StatementInfo>");
                    source.AppendLine($"{indent}            {{");
                    
                    if (ifStmt.Else.Statement is BlockSyntax elseBlock)
                    {
                        foreach (var childStatement in elseBlock.Statements)
                        {
                            GenerateStatementInitializer(childStatement, source, indent + "                ", semanticModel);
                            source.Append(",");
                            source.AppendLine();
                        }
                    }
                    else
                    {
                        GenerateStatementInitializer(ifStmt.Else.Statement, source, indent + "                ", semanticModel);
                        source.Append(",");
                        source.AppendLine();
                    }
                    
                    source.AppendLine($"{indent}            }}");
                    source.AppendLine($"{indent}        }},");
                }
                
                source.AppendLine($"{indent}    }}");
            }
            // Handle expressions
            else if (statement is ExpressionStatementSyntax exprStmt)
            {
                source.AppendLine($"{indent}    Expressions = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(exprStmt.Expression, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
            }
            // Handle return statements
            else if (statement is ReturnStatementSyntax returnStmt)
            {
                if (returnStmt.Expression != null)
                {
                    source.AppendLine($"{indent}    Expressions = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}    {{");
                    
                    GenerateExpressionInitializer(returnStmt.Expression, source, indent + "        ", semanticModel);
                    
                    source.AppendLine();
                    source.AppendLine($"{indent}    }}");
                }
            }
            // Handle local declarations
            else if (statement is LocalDeclarationStatementSyntax localDecl)
            {
                source.AppendLine($"{indent}    Expressions = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                foreach (var variable in localDecl.Declaration.Variables)
                {
                    source.AppendLine($"{indent}        new ExpressionInfo");
                    source.AppendLine($"{indent}        {{");
                    source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.Identifier,");
                    
                    // Resolve the variable type using semantic model
                    var typeInfo = semanticModel.GetTypeInfo(localDecl.Declaration.Type);
                    if (typeInfo.Type != null)
                    {
                        string typeFullName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}            ResultType = typeof({typeFullName}),");
                    }
                    
                    // If there's an initializer, include it with proper type resolution
                    if (variable.Initializer != null)
                    {
                        source.AppendLine($"{indent}            Children = new List<ExpressionInfo>");
                        source.AppendLine($"{indent}            {{");
                        
                        GenerateExpressionInitializer(variable.Initializer.Value, source, indent + "                ", semanticModel);
                        
                        source.AppendLine();
                        source.AppendLine($"{indent}            }}");
                    }
                    
                    source.AppendLine($"{indent}        }},");
                }
                
                source.AppendLine($"{indent}    }}");
            }
            
            source.AppendLine($"{indent}}}");
        }

        /// <summary>
        /// Generate an expression body with semantic model for proper type resolution
        /// </summary>
        private static void GenerateExpressionBodyWithSemanticModel(ArrowExpressionClauseSyntax expressionBody, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            source.AppendLine($"{indent}new StatementInfo");
            source.AppendLine($"{indent}{{");
            source.AppendLine($"{indent}    Kind = StatementInfo.StatementKind.ExpressionBody,");
            source.AppendLine($"{indent}    Expressions = new List<ExpressionInfo>");
            source.AppendLine($"{indent}    {{");
            
            GenerateExpressionInitializer(expressionBody.Expression, source, indent + "        ", semanticModel);
            
            source.AppendLine();
            source.AppendLine($"{indent}    }}");
            source.AppendLine($"{indent}}}");
        }

        /// <summary>
        /// Generate an expression with semantic model for proper type resolution
        /// </summary>
        private static void GenerateExpressionInitializer(ExpressionSyntax expression, StringBuilder source, string indent, SemanticModel semanticModel)
        {
            if (expression == null)
            {
                source.AppendLine($"{indent}null");
                return;
            }
            
            // Get type information using semantic model
            var typeInfo = semanticModel.GetTypeInfo(expression);
            string typeName = "object";
            if (typeInfo.Type != null)
            {
                typeName = typeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
            
            // Object creation expressions (e.g. new Vector3(0,0,0))
            if (expression is ObjectCreationExpressionSyntax objectCreationExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.ObjectCreation,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Arguments list
                if (objectCreationExpr.ArgumentList != null && objectCreationExpr.ArgumentList.Arguments.Count > 0)
                {
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}    {{");
                    
                    int argIndex = 0;
                    foreach (var arg in objectCreationExpr.ArgumentList.Arguments)
                    {
                        GenerateExpressionInitializer(arg.Expression, source, indent + "        ", semanticModel);
                        
                        if (argIndex < objectCreationExpr.ArgumentList.Arguments.Count - 1)
                        {
                            source.Append(",");
                        }
                        source.AppendLine();
                        argIndex++;
                    }
                    
                    source.AppendLine($"{indent}    }}");
                }
                
                source.AppendLine($"{indent}}}");
            }
            // Post-increment and post-decrement expressions (i++, i--)
            else if (expression is PostfixUnaryExpressionSyntax postfixExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.PostfixUnary,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{postfixExpr.OperatorToken.Text}\",");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(postfixExpr.Operand, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Pre-increment and pre-decrement expressions (++i, --i)
            else if (expression is PrefixUnaryExpressionSyntax prefixExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.PrefixUnary,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{prefixExpr.OperatorToken.Text}\",");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(prefixExpr.Operand, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Method invocations
            else if (expression is InvocationExpressionSyntax invocationExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.MethodInvocation,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Target method information
                var symbolInfo = semanticModel.GetSymbolInfo(invocationExpr);
                if (symbolInfo.Symbol is IMethodSymbol methodSymbol)
                {
                    string containingTypeName = methodSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    
                    // Build parameter types array for precise method resolution
                    string parameterTypesArray;
                    
                    if (methodSymbol.Parameters.Length > 0)
                    {
                        var typesBuilder = new StringBuilder("new Type[] { ");
                        
                        for (int i = 0; i < methodSymbol.Parameters.Length; i++)
                        {
                            var param = methodSymbol.Parameters[i];
                            string paramTypeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            
                            typesBuilder.Append($"typeof({paramTypeName})");
                            
                            if (i < methodSymbol.Parameters.Length - 1)
                                typesBuilder.Append(", ");
                        }
                        
                        typesBuilder.Append(" }");
                        parameterTypesArray = typesBuilder.ToString();
                    }
                    else
                    {
                        parameterTypesArray = "new Type[0]";
                    }
                    
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    Method = typeof({containingTypeName}).GetMethod(\"{methodSymbol.Name}\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, {parameterTypesArray}, null)");
                }
                
                // Target expression and arguments
                source.AppendLine($"{indent},");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Target expression (e.g. obj in obj.Method())
                if (invocationExpr.Expression is MemberAccessExpressionSyntax memberAccess)
                {
                    GenerateExpressionInitializer(memberAccess.Expression, source, indent + "        ", semanticModel);
                    source.Append(",");
                    source.AppendLine();
                }
                
                // Arguments
                int argIdx = 0;
                foreach (var arg in invocationExpr.ArgumentList.Arguments)
                {
                    GenerateExpressionInitializer(arg.Expression, source, indent + "        ", semanticModel);
                    
                    if (argIdx < invocationExpr.ArgumentList.Arguments.Count - 1)
                    {
                        source.Append(",");
                    }
                    source.AppendLine();
                    argIdx++;
                }
                
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Member access (e.g. obj.Property)
            else if (expression is MemberAccessExpressionSyntax memberAccessExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.MemberAccess,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Determine if it's a property or field
                var symbolInfo = semanticModel.GetSymbolInfo(memberAccessExpr.Name);
                if (symbolInfo.Symbol is IPropertySymbol propertySymbol)
                {
                    string containingTypeName = propertySymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    Property = typeof({containingTypeName}).GetProperty(\"{propertySymbol.Name}\")");
                }
                else if (symbolInfo.Symbol is IFieldSymbol fieldSymbol)
                {
                    string containingTypeName = fieldSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    Field = typeof({containingTypeName}).GetField(\"{fieldSymbol.Name}\")");
                }
                
                // The object being accessed
                source.AppendLine($"{indent},");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(memberAccessExpr.Expression, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Literal values (e.g. "string", 42, true)
            else if (expression is LiteralExpressionSyntax literalExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Literal,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Get the literal value
                var constantValue = semanticModel.GetConstantValue(expression);
                if (constantValue.HasValue)
                {
                    object value = constantValue.Value;
                    if (value is string stringValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = \"{stringValue.Replace("\"", "\\\"")}\"");
                    }
                    else if (value == null)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = null");
                    }
                    else if (value is double doubleValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {doubleValue.ToString(CultureInfo.InvariantCulture)}");
                    }
                    else if (value is float floatValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {floatValue.ToString(CultureInfo.InvariantCulture)}f");
                    }
                    else if (value is decimal decimalValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {decimalValue.ToString(CultureInfo.InvariantCulture)}m");
                    }
                    else
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {Convert.ToString(value, CultureInfo.InvariantCulture)}");
                    }
                }
                
                source.AppendLine($"{indent}}}");
            }
            // Numeric literals 
            else if (expression.IsKind(SyntaxKind.NumericLiteralExpression))
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Literal,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Get the numeric value
                var constantValue = semanticModel.GetConstantValue(expression);
                if (constantValue.HasValue)
                {
                    object value = constantValue.Value;
                    if (value is int intValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {intValue}");
                    }
                    else if (value is double doubleValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {doubleValue.ToString(CultureInfo.InvariantCulture)}");
                    }
                    else if (value is float floatValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {floatValue.ToString(CultureInfo.InvariantCulture)}f");
                    }
                    else if (value is decimal decimalValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {decimalValue.ToString(CultureInfo.InvariantCulture)}m");
                    }
                    else if (value is long longValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {longValue}L");
                    }
                    else if (value is uint uintValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {uintValue}U");
                    }
                    else if (value is ulong ulongValue)
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {ulongValue}UL");
                    }
                    else
                    {
                        source.AppendLine($"{indent},");
                        source.AppendLine($"{indent}    LiteralValue = {Convert.ToString(value, CultureInfo.InvariantCulture)}");
                    }
                }
                else
                {
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    LiteralValue = \"{expression.ToString()}\"");
                }
                
                source.AppendLine($"{indent}}}");
            }
            // Identifiers (variable names)
            else if (expression is IdentifierNameSyntax identifierExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Identifier,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    LiteralValue = \"{identifierExpr.Identifier.Text}\"");
                source.AppendLine($"{indent}}}");
            }
            // Binary expressions (e.g. a + b)
            else if (expression is BinaryExpressionSyntax binaryExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Binary,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{binaryExpr.OperatorToken.Text}\",");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Left expression
                GenerateExpressionInitializer(binaryExpr.Left, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // Right expression
                GenerateExpressionInitializer(binaryExpr.Right, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Assignment expressions (a = b)
            else if (expression is AssignmentExpressionSyntax assignmentExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Assignment,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"{assignmentExpr.OperatorToken.Text}\",");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Left expression
                GenerateExpressionInitializer(assignmentExpr.Left, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // Right expression
                GenerateExpressionInitializer(assignmentExpr.Right, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Element access expressions (e.g. array[index])
            else if (expression is ElementAccessExpressionSyntax elementAccessExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.ElementAccess,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // The expression being accessed (e.g., the array/list)
                source.AppendLine($"{indent}        // Array/collection expression");
                GenerateExpressionInitializer(elementAccessExpr.Expression, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // Process all arguments (indexes)
                int argIndex = 0;
                foreach (var arg in elementAccessExpr.ArgumentList.Arguments)
                {
                    source.AppendLine($"{indent}        // Index expression {argIndex + 1}");
                    GenerateExpressionInitializer(arg.Expression, source, indent + "        ", semanticModel);
                    
                    if (argIndex < elementAccessExpr.ArgumentList.Arguments.Count - 1)
                    {
                        source.Append(",");
                    }
                    source.AppendLine();
                    argIndex++;
                }
                
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Interpolated string expressions ($"Hello {name}")
            else if (expression is InterpolatedStringExpressionSyntax interpolatedStringExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.InterpolatedString,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");

                // Process string contents and interpolations
                if (interpolatedStringExpr.Contents.Count > 0)
                {
                    source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}    {{");
                    
                    int contentIndex = 0;
                    foreach (var content in interpolatedStringExpr.Contents)
                    {
                        if (content is InterpolationSyntax interpolation)
                        {
                            // Process interpolated expression
                            GenerateExpressionInitializer(interpolation.Expression, source, indent + "        ", semanticModel);
                        }
                        else if (content is InterpolatedStringTextSyntax textContent)
                        {
                            // Process text content
                            source.AppendLine($"{indent}        new ExpressionInfo");
                            source.AppendLine($"{indent}        {{");
                            source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.Literal,");
                            source.AppendLine($"{indent}            ResultType = typeof(string),");
                            source.AppendLine($"{indent}            LiteralValue = \"{textContent.TextToken.ValueText.Replace("\"", "\\\"")}\"");
                            source.AppendLine($"{indent}        }}");
                        }
                        
                        if (contentIndex < interpolatedStringExpr.Contents.Count - 1)
                        {
                            source.Append(",");
                        }
                        source.AppendLine();
                        contentIndex++;
                    }
                    
                    source.AppendLine($"{indent}    }}");
                }
                
                source.AppendLine($"{indent}}}");
            }
            // Anonymous object creation expressions (new { Name = "value" })
            else if (expression is AnonymousObjectCreationExpressionSyntax anonymousObjectExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.AnonymousObject,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                
                // Process initializers
                if (anonymousObjectExpr.Initializers.Count > 0)
                {
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}    {{");
                    
                    int initIndex = 0;
                    foreach (var initializer in anonymousObjectExpr.Initializers)
                    {
                        source.AppendLine($"{indent}        new ExpressionInfo");
                        source.AppendLine($"{indent}        {{");
                        source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.Assignment,");
                        
                        // Get the type of the initializer expression
                        var initTypeInfo = semanticModel.GetTypeInfo(initializer.Expression);
                        if (initTypeInfo.Type != null)
                        {
                            string initTypeName = initTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            source.AppendLine($"{indent}            ResultType = typeof({initTypeName}),");
                        }
                        
                        // Store property name
                        string propertyName = initializer.NameEquals?.Name.ToString() ?? 
                                             (initializer.Expression is IdentifierNameSyntax idName ? idName.Identifier.Text : "anonymousProperty");
                        
                        source.AppendLine($"{indent}            LiteralValue = \"{propertyName}\",");
                        source.AppendLine($"{indent}            Children = new List<ExpressionInfo>");
                        source.AppendLine($"{indent}            {{");
                        
                        // Process expression
                        GenerateExpressionInitializer(initializer.Expression, source, indent + "                ", semanticModel);
                        
                        source.AppendLine();
                        source.AppendLine($"{indent}            }}");
                        source.AppendLine($"{indent}        }}");
                        
                        if (initIndex < anonymousObjectExpr.Initializers.Count - 1)
                        {
                            source.Append(",");
                        }
                        source.AppendLine();
                        initIndex++;
                    }
                    
                    source.AppendLine($"{indent}    }}");
                }
                
                source.AppendLine($"{indent}}}");
            }
            // Default value expression (default(Type) or default)
            else if (expression is DefaultExpressionSyntax defaultExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.DefaultValue,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName})");
                source.AppendLine($"{indent}}}");
            }
            // Typeof expressions (typeof(Type))
            else if (expression is TypeOfExpressionSyntax typeOfExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.TypeOf,");
                source.AppendLine($"{indent}    ResultType = typeof(System.Type),");
                
                // Get the actual type from the argument
                var actualType = semanticModel.GetTypeInfo(typeOfExpr.Type).Type;
                string actualTypeName = actualType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? 
                                      typeOfExpr.Type.ToString();
                
                source.AppendLine($"{indent}    LiteralValue = \"{actualTypeName}\"");
                source.AppendLine($"{indent}}}");
            }
            // Nameof expressions (nameof(identifier))
            else if (expression is InvocationExpressionSyntax nameofInvocation && 
                    nameofInvocation.Expression is IdentifierNameSyntax nameofIdentifier && 
                    nameofIdentifier.Identifier.Text == "nameof")
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.NameOf,");
                source.AppendLine($"{indent}    ResultType = typeof(string)");
                
                // Get the argument (should be just one)
                if (nameofInvocation.ArgumentList.Arguments.Count > 0)
                {
                    var arg = nameofInvocation.ArgumentList.Arguments[0].Expression;
                    string nameValue;
                    
                    // Extract the last identifier from chained member accesses
                    if (arg is MemberAccessExpressionSyntax memberAccess)
                    {
                        nameValue = memberAccess.Name.Identifier.Text;
                    }
                    else if (arg is IdentifierNameSyntax idName)
                    {
                        nameValue = idName.Identifier.Text;
                    }
                    else
                    {
                        nameValue = arg.ToString();
                    }
                    
                    source.AppendLine($"{indent},");
                    source.AppendLine($"{indent}    LiteralValue = \"{nameValue}\"");
                }
                
                source.AppendLine($"{indent}}}");
            }
            // Null-coalescing operator (??)
            else if (expression is BinaryExpressionSyntax nullCoalescingExpr && 
                    nullCoalescingExpr.OperatorToken.Kind() == SyntaxKind.QuestionQuestionToken)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.NullCoalescing,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Operator = \"??\",");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Left expression (potentially null)
                GenerateExpressionInitializer(nullCoalescingExpr.Left, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // Right expression (fallback)
                GenerateExpressionInitializer(nullCoalescingExpr.Right, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Is-pattern expressions (x is int i)
            else if (expression is IsPatternExpressionSyntax isPatternExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.IsPattern,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Expression being tested
                GenerateExpressionInitializer(isPatternExpr.Expression, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // Pattern description
                source.AppendLine($"{indent}        new ExpressionInfo");
                source.AppendLine($"{indent}        {{");
                source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.Literal,");
                source.AppendLine($"{indent}            ResultType = typeof(string),");
                source.AppendLine($"{indent}            LiteralValue = \"{isPatternExpr.Pattern}\"");
                source.AppendLine($"{indent}        }}");
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Switch expressions
            else if (expression is SwitchExpressionSyntax switchExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.SwitchExpression,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // First child is always the governing expression
                GenerateExpressionInitializer(switchExpr.GoverningExpression, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // Then add each switch arm as children
                int armIdx = 0;
                foreach (var arm in switchExpr.Arms)
                {
                    source.AppendLine($"{indent}        new ExpressionInfo");
                    source.AppendLine($"{indent}        {{");
                    source.AppendLine($"{indent}            Kind = ExpressionInfo.ExpressionKind.SwitchArm,");
                    source.AppendLine($"{indent}            Children = new List<ExpressionInfo>");
                    source.AppendLine($"{indent}            {{");
                    
                    // Pattern is first child of arm
                    source.AppendLine($"{indent}                new ExpressionInfo");
                    source.AppendLine($"{indent}                {{");
                    source.AppendLine($"{indent}                    Kind = ExpressionInfo.ExpressionKind.SwitchPattern");
                    
                    // Get type info for pattern if possible
                    var patternTypeInfo = semanticModel.GetTypeInfo(arm.Pattern);
                    if (patternTypeInfo.Type != null)
                    {
                        string patternTypeName = patternTypeInfo.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        source.AppendLine($"{indent}                    ,");
                        source.AppendLine($"{indent}                    ResultType = typeof({patternTypeName})");
                    }
                    
                    source.AppendLine($"{indent}                    ,");
                    source.AppendLine($"{indent}                    LiteralValue = \"{arm.Pattern.ToString().Replace("\"", "\\\"")}\"");
                    source.AppendLine($"{indent}                }},");
                    
                    // Expression is second child of arm
                    GenerateExpressionInitializer(arm.Expression, source, indent + "                ", semanticModel);
                    
                    source.AppendLine();
                    source.AppendLine($"{indent}            }}");
                    source.AppendLine($"{indent}        }}");
                    
                    if (armIdx < switchExpr.Arms.Count - 1)
                    {
                        source.Append(",");
                    }
                    source.AppendLine();
                    armIdx++;
                }
                
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Await expressions
            else if (expression is AwaitExpressionSyntax awaitExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.AwaitExpression,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(awaitExpr.Expression, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Parenthesized expressions
            else if (expression is ParenthesizedExpressionSyntax parenthesizedExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Parenthesized,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(parenthesizedExpr.Expression, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Cast expressions
            else if (expression is CastExpressionSyntax castExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Cast,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                GenerateExpressionInitializer(castExpr.Expression, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Conditional expressions (ternary operator: condition ? ifTrue : ifFalse)
            else if (expression is ConditionalExpressionSyntax conditionalExpr)
            {
                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Conditional,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    Children = new List<ExpressionInfo>");
                source.AppendLine($"{indent}    {{");
                
                // Condition
                source.AppendLine($"{indent}        // Condition");
                GenerateExpressionInitializer(conditionalExpr.Condition, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // WhenTrue
                source.AppendLine($"{indent}        // WhenTrue");
                GenerateExpressionInitializer(conditionalExpr.WhenTrue, source, indent + "        ", semanticModel);
                source.Append(",");
                source.AppendLine();
                
                // WhenFalse
                source.AppendLine($"{indent}        // WhenFalse");
                GenerateExpressionInitializer(conditionalExpr.WhenFalse, source, indent + "        ", semanticModel);
                
                source.AppendLine();
                source.AppendLine($"{indent}    }}");
                source.AppendLine($"{indent}}}");
            }
            // Default fallback for any other expression type
            else
            {
                // Emit a detailed warning in the generated code
                var warningMessage = $"WARNING: Unhandled expression type: {expression.GetType().Name} in '{expression}'. This will be processed as an Unknown expression.";
                source.AppendLine($"{indent}// {warningMessage}");
                
                // Also write to debug output for diagnostics during generation
                System.Diagnostics.Debug.WriteLine(warningMessage);
                
                // Try to provide more information from kind
                string kindName = expression.Kind().ToString();
                source.AppendLine($"{indent}// SyntaxKind: {kindName}");

                source.AppendLine($"{indent}new ExpressionInfo");
                source.AppendLine($"{indent}{{");
                source.AppendLine($"{indent}    Kind = ExpressionInfo.ExpressionKind.Unknown,");
                source.AppendLine($"{indent}    ResultType = typeof({typeName}),");
                source.AppendLine($"{indent}    // Using ToString() to capture at least the text representation");
                source.AppendLine($"{indent}    LiteralValue = \"{expression.ToString().Replace("\"", "\\\"")}\"");
                source.AppendLine($"{indent}}}");
            }
        }

        /// <summary>
        /// Get the appropriate StatementInfo.StatementKind for a statement
        /// </summary>
        private static string GetStatementKind(StatementSyntax statement)
        {
            if (statement is BlockSyntax) return "Block";
            if (statement is IfStatementSyntax) return "If";
            if (statement is ForStatementSyntax) return "For";
            if (statement is ForEachStatementSyntax) return "ForEach";
            if (statement is WhileStatementSyntax) return "While";
            if (statement is DoStatementSyntax) return "Do";
            if (statement is SwitchStatementSyntax) return "Switch";
            if (statement is ReturnStatementSyntax) return "Return";
            if (statement is ExpressionStatementSyntax) return "Expression";
            if (statement is LocalDeclarationStatementSyntax) return "Declaration";
            if (statement is BreakStatementSyntax) return "Break";
            if (statement is ContinueStatementSyntax) return "Continue";
            if (statement is ThrowStatementSyntax) return "Throw";
            if (statement is TryStatementSyntax) return "Try";
            
            // Log warning for unknown statement type with more detailed information
            var warningMessage = $"WARNING: Unknown statement type: {statement.GetType().Name} in '{statement}'. Using Unknown statement kind.";
            System.Diagnostics.Debug.WriteLine(warningMessage);
            
            return "Unknown";
        }
    }
}